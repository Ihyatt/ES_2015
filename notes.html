<!DOCTYPE html>
<html>
<head>
<title>ES 2015 Notes : )</title>
</head>
<body>

<h1>Level One</h1>
<h2>Using Let</h2>
<ul>
	<li> Prior to executing our code, JavaScript moves <em>var</em> declarations all the way up to the top of the scope. This is known as <b>hoisting</b>. 	

	<li><em>let</em> variables are scoped to the nearest <b>block</b> and are <b>NOT HOISTED</b>. (A block is any code section within <b>curly braces</b>, like <em>if, else, for, while,</em>, etc)
	<li> Use <em>let</em>, variables are "trapped" inside their respective <em>if</em> and <em>else</em> blocks.touch 
</ul>


<h2>1.4 using let in for loops</h2>

<ul>
	<li> <em>var</em> is the reason behind a popular "gotcha" in <em>for</em> loops.
	<li> With <em>let</em>, there's <b>no sharing</b> in <em>for</em> loops. A new variable is created on each iteration.
	<li> Variables declared with <em> let</em> can be reassigned, but cannot be <b>redeclared</b> within the same scope.
	
</ul>

<h2>1.9 Using const</h2>
<ul>
	<li> <b>Magic Numbers</b> - a magic numners is a literal value with a clear meaning. 
	<li> When used multiple times, magic numbers introduce <b>unnecassary duplication</b>, which can lead to <b>bad code</b>!
	<li> The <em>const</em> keyword creates <b>read-only</b> named constants.
	<li> Once assigned, constants <b>cannot</b> be assigned a new value. 
	<li> Variables declared with <em>const</em> are scoped to the nearest block. 
	<li> In most cases, <em>let</em> and <em>const</em> will behave very similarly. Consider the semantics when choosing one over the other. 
	<li> Use <b>let</b> when variables could be reassigned new values.
	<li> Use <b>const</b> when new variables are not expected to be reassigned new values.
</ul>

<h1>Level Two</h1>
<h2>2.0 Function Defaults</h2>
<ul>
	<li> A common practice is to <b>check for presence</b> of arguments as the very first thing in the function.
	<li> Default parameter values help move <b>default values</b> from the function body to the function signature.
	<li> <b>The Options Object</b> - the options object is a widely used pattern that allows user-defined settings to be passed to a function in the form of properties on an object.
	<li> <b>Using Named Parameters</b> - Using named parameters for optional settings makes it easier to understand how a function should be invoked. 
	<li> It's <b>NOT okay</b> to omit the options argument altogether when invoking a function with named parameters when no default value is set for them. 	

</ul>

<h2>2.7 Rest Params, Spread Op, Arrow Func</h2>
<ul>
	<li><b>Variadic functions</b> can take in any number of arguments
	<li> The <em>arguments</em> object is a built-in, Array-like object that corresponds to the arguments of a function. Here's why relying on this object to read arguments is <b>not ideal.</b>
	<li> The new <em>rest parameter</em> syntax allows us to represent an indefinite number of arguments as an Array. This way, changes to function signature are <b>less likeley to break code</b>.
	<li> The spread operator allows us to <b>split an Array</b> argument into <b>individual elements</b>.
	<li> <b>Rest and Spread look the same</b>Rest parameters and the spread operator <b>look the same</b>, but the former is used in function <b>definitions</b> and the later in function <b>invocations</b>.
	<li><b>From functions to Objects</b> - JavaScript objects can help use with the <b>encapsulation, organization</b>, and <b>testability</b> of our code. 
	<li> The <em>TagComponent</em> object <b>encapsulates</b> the code for fetching tags and adding them to a page.
	<li> Anonymos functions passed as callback to other functions create <b>their own scope</b>.
	<li> Arrow functions bind to the scope of where they are <b>defined</b>, not where they are used. (also knows as <b>lexical binding</b>)
</ul>
<h1>Level Three</h1>
<h2>3.1 Objects and Strings</h2>
<ul>
	<li><b>Object Initializer Shorthand Syntax</b> - From variable to object properties
	<li> <b>Object Destructuring</b>From object properties to variables
	<li> <b>Template Strings</b> template strings are <b>string literals</b> allowing embedded expressions. This allows for a much better way to do <b>string interpolation</b>.
	<li> Template strings offer a new - and much better - way to write <b>multi-line strings</b>


</ul>

<h2>3.9 Object.assign</h2>
<ul>
	<li>In order to cater to different applications and domains, our <em>countdownTimer</em> function needs to be called in <b>many different ways</b>
	<li> For functions that need to be used acrossdifferent applications, it's okay to accept an <b>option object</b> instead of using named parameters
	<li> Some options might not be specified by the caller, so we need to have <b>default values</b>
	<li> Using a local object to group <b>default</b> values for user options is a common practice and can help write more <b>idiomatic JavaScript</b>
	<li> We want to merge <em>options</em> and <em>defaults</em>. Upon dplicate properties, those from <em>options</em><b>must override properties</b> from <em>defaults</em>.
	<li> The <em>Object.assign</em> method copies properties from one or more <b>source objects</b> to a <b>target obejct</b> specified as the very first argument. In case of <b>duplicate properties</b> on source objects, the value from the <b>last object</b> on the chain always prevails. 
	<li> Preserving the original default values gives us the ability to compare them with the options passed and act accordingly when necassary 

</ul>
<h1>Level Four</h1>
<h2>4.1 Arrays</h2>
<ul>
	<li>We typically access array elements by their index, but doing so for more than just a couple of elements can quickly turn into a <b>repetitive task</b>.
	<li> We can <b>combine</b> destructuring with rest paramters to <b>group values</b> into other arrays
	<li> The <em> for...of</em> statement iterates over <b>property values</b>, and it's a better way to loop over arrays and other <b>iterable objects</b>
	<li> The <em>for...of</em> statement <b>cannot</b> be used to iterate over properties in plain JavaScript objects out-of-the-box.
	<li> In order to work with <em>for...of</em>, objects need a special function assigned to the <em>Symbol.iterator</em> propert. The presence of this property allows us to know whether an object is <b>iterable</b>. 
	<li> No function assigned to the <em>Symbol.iterator</em> property means the object is <b>not iterable</b>.
	<li> <em>Array.find</em> returns the <b>first element</b> in the array that satisfies a provided testing function. 
</ul>


</body>
</html>